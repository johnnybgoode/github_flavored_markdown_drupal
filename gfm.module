<?php

/**
 * Implements of hook_filter().
 */
function gfm_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(0 => t('Github Flavored Markdown'));

		case 'no cache': // Development & testing only
			return TRUE;

    case 'description':
      return t('Provides added functionality to Markdown filter. Ensure GFM is run first.');

    case 'process':
			return _gfm_process_text($text, $format);

		case 'settings':
			return _gfm_settings($format);

    default:
      return $text;
  }
}

/**
 *	Process callback
 */
function _gfm_process_text($text, $format) {
	if ( !empty($text) ) {
		// Implement fenced code blocks
		if ( variable_get('gfm_fenced_code_'.$format, 0) ) {
			$text = preg_replace_callback('/(`{3})(.*)\1/s', '_gfm_fenced_code_callback', $text);
		}

		// Prevent foo_bar_baz from ending up with an italic word in the middle
		if ( variable_get('gfm_escape_underscores_'.$format, 0) ) {
			$text = preg_replace_callback('/((?! {4}|\t)\w+_\w+_\w[\w_]*)/', '_gfm_escape_underscores_callback', $text);
		}

		// Autolink urls
		if ( variable_get('gfm_autolink_'.$format, 0) ) {
			$text = gfm_autolink($text);
		}

		// Let single newlines become <br /> tags
		if ( variable_get('gfm_replace_newlines_'.$format, 0) ) {
			$text = preg_replace_callback('/[\w\<][^\n]*\n+/', '_gfm_replace_newlines_callback', $text);
		}
	}
	return $text;
}

/*
 *	Helper for replacing newlines
 */
function _gfm_replace_newlines_callback($matches) {
	if ( preg_match('/\n\n/', $matches[0]) ) {
		return $matches[0];
	}
	else {
		return trim($matches[0]) . "  \n";
	}
}

/*
 *	Helper for escaping underscores
 */
function _gfm_escape_underscores_callback($matches) {
	return str_replace('_', '\_', $matches[0]);
}

/*
 *  Helper for indenting fenced code blocks
 */
function _gfm_fenced_code_callback($matches) {
	$lines = explode("\n", $matches[2]);
	$text = '';
	foreach ( $lines as $line ) {
		$text .= '    ' . $line . "\n";
	}
	return $text;
}

function _gfm_autolink($text) {
	//$autolink = new GFM_Autolink();
	$text = preg_replace_callback('{
		(?<!]:\s)								# attempt to ignore link definitions of reference-style links
		(?<=\A|[\t\n ])					# positive lookbehind for BOF or tab, newline, or space
			((f|ht)tps?://){0,1}	# optional scheme name, only ftp/http/https
			([-\w]+\.)+           # server name(s) and domain
			[a-zA-Z0-9]{2,3}      # TLD
			.*?										# query string, fragment, etc
		(?=\Z|[\t\n ])					# positive lookahead for EOF or tab, newline, or space
		}x',
		'_gfm_autolink_callback', $text);
	//$text .= $autolink->_gfm_append_urls();
	return $text;
}

function _gfm_autolink_callback($matches) {
	$url = $matches[0];
	return '[' . $url . '](' . (preg_match('{^(f|ht)tps?://}',$url)) ? $url : 'http://'.$url . ')';
}

/**
 *	Settings callback
 */
function _gfm_settings($format) {
	return array(
		'gfm_autolink_'.$format => array(
			'#type' => 'checkbox',
			'#title' => t('Enable Autolinking'),
			'#default_value' => variable_get('gfm_autolink_'.$format, 1),
		),
		'gfm_fenced_code_'.$format => array(
			'#type' => 'checkbox',
			'#title' => t('Enable Fenced Code'),
			'#default_value' => variable_get('gfm_fenced_code_'.$format, 1),
		),
		'gfm_escape_underscores_'.$format => array(
			'#type' => 'checkbox',
			'#title' => t('Escape Underscores in Words'),
			'#default_value' => variable_get('gfm_escape_underscores_'.$format, 1),
		),
		'gfm_replace_newlines_'.$format => array(
			'#type' => 'checkbox',
			'#title' => t('Hard Wrap Single Newlines'),
			'#default_value' => variable_get('gfm_replace_newlines_'.$format, 1),
		),
	);
}
